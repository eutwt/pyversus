{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"pyversus","text":"<p>DuckDB-powered tools for comparing two relations (tables, views, or SQL queries) without materializing them in Python.</p> <p>Alpha status</p> <p>This package is still evolving and may change between releases.</p>"},{"location":"#quick-start","title":"Quick start","text":"<pre><code>import duckdb\nfrom versus import compare, examples\n\ncon = duckdb.connect()\nrel_a = examples.example_cars_a(con)\nrel_b = examples.example_cars_b(con)\n\ncomparison = compare(rel_a, rel_b, by=[\"car\"], connection=con)\ncomparison\n</code></pre> <p>From the returned <code>Comparison</code>, you can ask for specific views of the differences:</p> <pre><code>comparison.value_diffs(\"disp\")\ncomparison.value_diffs_stacked([\"mpg\", \"disp\"])\ncomparison.weave_diffs_wide([\"mpg\", \"disp\"])\ncomparison.weave_diffs_long([\"disp\"])\ncomparison.slice_diffs(\"a\", [\"mpg\"])\ncomparison.slice_unmatched(\"b\")\ncomparison.slice_unmatched_both()\ncomparison.summary()\n</code></pre>"},{"location":"getting-started/","title":"Getting started","text":""},{"location":"getting-started/#installation","title":"Installation","text":"<p>Clone the repository and install it into your environment:</p> <pre><code>pip install -e .\n</code></pre> <p>The only runtime dependency is DuckDB.</p>"},{"location":"getting-started/#inputs","title":"Inputs","text":"<p><code>compare()</code> accepts DuckDB relations (tables, views, or SQL queries). If you provide relations created on a non-default connection, pass that connection into <code>compare()</code> so helper queries run in the same session.</p> <pre><code>import duckdb\nfrom versus import compare\n\ncon = duckdb.connect()\nrel_a = con.sql(\"SELECT 1 AS id, 10 AS value\")\nrel_b = con.sql(\"SELECT 1 AS id, 12 AS value\")\n\ncomparison = compare(rel_a, rel_b, by=[\"id\"], connection=con)\ncomparison.summary()\n</code></pre>"},{"location":"getting-started/#materialization-modes","title":"Materialization modes","text":"<p><code>materialize</code> controls how much data is computed eagerly:</p> <ul> <li><code>all</code>: build summary tables and diff keys up front for fastest helpers.</li> <li><code>summary</code>: build summary tables, but compute diff keys lazily.</li> <li><code>none</code>: keep summaries lazy until printed or queried.</li> </ul>"},{"location":"reference/compare/","title":"compare","text":""},{"location":"reference/compare/#versus.compare","title":"compare","text":"<pre><code>compare(\n    table_a: Any,\n    table_b: Any,\n    *,\n    by: Sequence[str],\n    allow_both_na: bool = True,\n    coerce: bool = True,\n    table_id: Tuple[str, str] = (\"a\", \"b\"),\n    connection: Optional[DuckDBPyConnection] = None,\n    materialize: Literal[\"all\", \"summary\", \"none\"] = \"all\",\n) -&gt; Comparison\n</code></pre> <p>Compare two DuckDB relations (or SQL queries) by key columns.</p> <p>Parameters:</p> Name Type Description Default <code>table_a</code> <code>Any</code> <p>DuckDB relations or SQL strings to compare.</p> required <code>table_b</code> <code>Any</code> <p>DuckDB relations or SQL strings to compare.</p> required <code>by</code> <code>sequence of str</code> <p>Column names that uniquely identify rows.</p> required <code>allow_both_na</code> <code>bool</code> <p>Whether to treat NULL/NA values as equal when both sides are missing.</p> <code>True</code> <code>coerce</code> <code>bool</code> <p>If True, allow DuckDB to coerce compatible types. If False, require exact type matches for shared columns.</p> <code>True</code> <code>table_id</code> <code>tuple[str, str]</code> <p>Labels used in outputs for the two tables.</p> <code>(\"a\", \"b\")</code> <code>connection</code> <code>DuckDBPyConnection</code> <p>DuckDB connection used to register the inputs and run queries.</p> <code>None</code> <code>materialize</code> <code>('all', 'summary', 'none')</code> <p>Controls which helper tables are materialized upfront.</p> <code>\"all\"</code> <p>Returns:</p> Type Description <code>Comparison</code> <p>Comparison object with summary relations and diff helpers.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import duckdb\n&gt;&gt;&gt; from versus import compare, examples\n&gt;&gt;&gt; con = duckdb.connect()\n&gt;&gt;&gt; comparison = compare(\n...     examples.example_cars_a(con),\n...     examples.example_cars_b(con),\n...     by=[\"car\"],\n...     connection=con,\n... )\n&gt;&gt;&gt; comparison.summary()\n</code></pre>"},{"location":"reference/comparison/","title":"Comparison","text":""},{"location":"reference/comparison/#versus.Comparison","title":"Comparison","text":"<pre><code>Comparison(\n    *,\n    connection: VersusConn,\n    handles: Mapping[str, _TableHandle],\n    table_id: Tuple[str, str],\n    by_columns: List[str],\n    allow_both_na: bool,\n    materialize_mode: str,\n    tables: DuckDBPyRelation,\n    by: DuckDBPyRelation,\n    intersection: DuckDBPyRelation,\n    unmatched_cols: DuckDBPyRelation,\n    unmatched_keys: DuckDBPyRelation,\n    unmatched_rows: DuckDBPyRelation,\n    common_columns: List[str],\n    table_columns: Mapping[str, List[str]],\n    diff_keys: Optional[Mapping[str, DuckDBPyRelation]],\n    diff_lookup: Optional[Dict[str, int]],\n)\n</code></pre> <p>In-memory description of how two relations differ.</p> <p>Provides summary relations plus helper methods to retrieve the exact differences without materializing the full input tables.</p>"},{"location":"reference/comparison/#versus.Comparison.value_diffs","title":"value_diffs","text":"<pre><code>value_diffs(column: str) -&gt; duckdb.DuckDBPyRelation\n</code></pre> <p>Return rows where a single column differs between the tables.</p> <p>Parameters:</p> Name Type Description Default <code>column</code> <code>str</code> <p>Column name to compare.</p> required <p>Returns:</p> Type Description <code>DuckDBPyRelation</code> <p>Relation with the differing values plus the <code>by</code> columns.</p>"},{"location":"reference/comparison/#versus.Comparison.value_diffs_stacked","title":"value_diffs_stacked","text":"<pre><code>value_diffs_stacked(\n    columns: Optional[Sequence[str]] = None,\n) -&gt; duckdb.DuckDBPyRelation\n</code></pre> <p>Return a stacked view of value differences for multiple columns.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>sequence of str</code> <p>Columns to compare. Defaults to all comparable columns.</p> <code>None</code> <p>Returns:</p> Type Description <code>DuckDBPyRelation</code> <p>Relation with <code>column</code>, <code>val_&lt;table_id&gt;</code>, and <code>by</code> columns.</p>"},{"location":"reference/comparison/#versus.Comparison.slice_diffs","title":"slice_diffs","text":"<pre><code>slice_diffs(\n    table: str, columns: Optional[Sequence[str]] = None\n) -&gt; duckdb.DuckDBPyRelation\n</code></pre> <p>Return rows from one table that differ in the selected columns.</p> <p>Parameters:</p> Name Type Description Default <code>table</code> <code>str</code> <p>Table identifier to return (one of <code>table_id</code>).</p> required <code>columns</code> <code>sequence of str</code> <p>Columns to check for differences. Defaults to all comparable columns.</p> <code>None</code> <p>Returns:</p> Type Description <code>DuckDBPyRelation</code> <p>Relation with the full schema of the requested table.</p>"},{"location":"reference/comparison/#versus.Comparison.slice_unmatched","title":"slice_unmatched","text":"<pre><code>slice_unmatched(table: str) -&gt; duckdb.DuckDBPyRelation\n</code></pre> <p>Return rows from one table whose keys are missing in the other.</p> <p>Parameters:</p> Name Type Description Default <code>table</code> <code>str</code> <p>Table identifier to return (one of <code>table_id</code>).</p> required <p>Returns:</p> Type Description <code>DuckDBPyRelation</code> <p>Relation with unmatched rows from the requested table.</p>"},{"location":"reference/comparison/#versus.Comparison.slice_unmatched_both","title":"slice_unmatched_both","text":"<pre><code>slice_unmatched_both() -&gt; duckdb.DuckDBPyRelation\n</code></pre> <p>Return unmatched rows from both tables.</p> <p>Returns:</p> Type Description <code>DuckDBPyRelation</code> <p>Relation with <code>table_name</code> plus key and common columns.</p>"},{"location":"reference/comparison/#versus.Comparison.weave_diffs_wide","title":"weave_diffs_wide","text":"<pre><code>weave_diffs_wide(\n    columns: Optional[Sequence[str]] = None,\n    suffix: Optional[Tuple[str, str]] = None,\n) -&gt; duckdb.DuckDBPyRelation\n</code></pre> <p>Return a wide view of differing rows with split columns.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>sequence of str</code> <p>Columns to compare. Defaults to all comparable columns.</p> <code>None</code> <code>suffix</code> <code>tuple[str, str]</code> <p>Suffixes appended to differing columns from table A and B.</p> <code>None</code> <p>Returns:</p> Type Description <code>DuckDBPyRelation</code> <p>Relation with key columns and common columns, where differing columns are split into <code>&lt;name&gt;&lt;suffix&gt;</code>.</p>"},{"location":"reference/comparison/#versus.Comparison.weave_diffs_long","title":"weave_diffs_long","text":"<pre><code>weave_diffs_long(\n    columns: Optional[Sequence[str]] = None,\n) -&gt; duckdb.DuckDBPyRelation\n</code></pre> <p>Return a long view of differing rows stacked by table.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>sequence of str</code> <p>Columns to compare. Defaults to all comparable columns.</p> <code>None</code> <p>Returns:</p> Type Description <code>DuckDBPyRelation</code> <p>Relation with <code>table_name</code> plus key and common columns.</p>"},{"location":"reference/comparison/#versus.Comparison.summary","title":"summary","text":"<pre><code>summary() -&gt; duckdb.DuckDBPyRelation\n</code></pre> <p>Summarize which difference categories are present.</p> <p>Returns:</p> Type Description <code>DuckDBPyRelation</code> <p>Relation with <code>difference</code> and <code>found</code> columns.</p>"},{"location":"reference/comparison/#versus.Comparison.close","title":"close","text":"<pre><code>close() -&gt; None\n</code></pre> <p>Release any temporary views or tables created for the comparison.</p>"},{"location":"reference/errors/","title":"Errors","text":""},{"location":"reference/errors/#versus.ComparisonError","title":"ComparisonError","text":"<p>               Bases: <code>ValueError</code></p> <p>Raised when comparison inputs are invalid or inconsistent.</p>"},{"location":"reference/examples/","title":"Examples","text":""},{"location":"reference/examples/#versus.examples","title":"examples","text":"<p>Example DuckDB relations for quick experimentation.</p>"},{"location":"reference/examples/#versus.examples.example_cars_a","title":"example_cars_a","text":"<pre><code>example_cars_a(\n    connection: Optional[DuckDBPyConnection] = None,\n) -&gt; duckdb.DuckDBPyRelation\n</code></pre> <p>Return the example table A as a DuckDB relation.</p>"},{"location":"reference/examples/#versus.examples.example_cars_b","title":"example_cars_b","text":"<pre><code>example_cars_b(\n    connection: Optional[DuckDBPyConnection] = None,\n) -&gt; duckdb.DuckDBPyRelation\n</code></pre> <p>Return the example table B as a DuckDB relation.</p>"}]}